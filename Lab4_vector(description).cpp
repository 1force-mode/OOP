#include <iostream>
#include <vector> //библиотека для контейнера с таким же названием, vector - динамический массив, который может менять свой размер в процессе работы программы
#include <string> //билиотека для работы со строками 

using namespace std;

/*
НЕБОЛЬШОЕ ПОЯСНЕНИЕ
Cтек работает по принципу LIFO (последний вошёл — первый вышел)
Стек можно представить в виде колоды карт, где мы кладём карты друг на друга.
В каком порядке положили, в таком и хранятся.
В случае, если мы хотим забрать карту, то забрать мы её можем только сверху.
*/

/*
template - это шаблон, который позволяет создавать обобщённые классы или функции 
template — ключевое слово, указывающее на начало шаблона
typename T — объявление параметра шаблона
T - это условное имя типа, компилятор сам определит и подставит нужный тип данных при создании
*/
template<typename T> 

//TrainStack - это шаблонный класс стека
class TrainStack {
private:
    vector<T> data; //это объявление динамического массива (вектора) элементов типа T 
    //<T> указывает, что вектор будет хранить элементы типа T (который задаётся при создании объекта), в нашем случае, типы вагонов

public:
    //функция, которая добавляет элемент в конец вектора
    void push(const T& value) {
        data.push_back(value);
    }

    //удаляет последний элемент
    void pop() {
        if (!empty()) {
            data.pop_back();
        }
    }

    //функция, которая возвращает последний элемент вектора, позволяет просмотреть его и изменить
    T& top() {
        return data.back();
    }

    //функция, которая возвращает последний элемент вектора, позволяет только просмотреть его
    const T& top() const {
        return data.back();
    }

    //функция, которая проверяет, пуст ли вектор
    bool empty() const {
        return data.empty();
    }

    //функция, которая возвращает количество элементов
    size_t size() const {
        return data.size();
    }
};

//Класс, который описывает объект "поезд" (Train), какой он может быть и что он умеет
class Train {
public:
    //enum - это перечисление, которое определяет какого типа вагоны у нас могут быть. Он нужен, чтобы чётко обозначить, что вагон может быть только 2 типов
    //enum - это тип данных, который позволяет задать набор именнованых констант
    enum WagonType {
        Wood, // 0 (нулевой элемент)
        Steel // 1 (первый элемент)
    };

private:
    //TrainStack<WagonType> wagons - cтек (вектор) с названием "wagons", который представляет из себя состав с типами вагонов, которые определены выше
    //TrainStack - стек (вектор)
    //WagonType - какие данные содержит стек (вектор), а именно типы вагонов
    //wagons - название вектора (стека)
    TrainStack<WagonType> wagons;

public:
    //Функция (правильнее называть "метод"), которая создаёт и заполняет стек (вектор), на основе ведённых пользователем значений
    void createTrain(int wagonCount) {
        //цикл, который очищает текущий состав. Цикл выполняется, пока стек не станет пустым
        while (!wagons.empty()) {
            wagons.pop(); //удаляет верхний вагон из стека
        }

        //цикл, который заполняет новый состав, зависит от wagonCount, сколько вагонов было введено, такой длины и будет наш поезд
        for (int i = 0; i < wagonCount; i++) {
            int type;
            cout << "Enter wagon type " << i + 1 << " (0 - wood, 1 - steel): ";
            cin >> type;
            wagons.push(static_cast<WagonType>(type)); //добавляет вагон в конец стека
            //static_cast - преобразует int (0 и 1) в тип вагона, в соответсвии с его нумерацией в перечислении enum
        }
    }
    
    //Функция (метод), которая сортирует вагоны, распределяя их по отдельным поездам (поезд = стек)
    void sortTrains() {
        TrainStack<WagonType> woodTrain, steelTrain; //создаём два поезда (стека), который будут содержать вагоны только определённого типа

        //Распределяем вагоны по типам
        //Цикл, который распределяет вагоны, пока оригинальный (смешанный) поезд (стек) не станет пустым
        while (!wagons.empty()) {
            WagonType wagon = wagons.top(); //получаем верхний элемент стека (последний вагон поезда)
            wagons.pop(); //удаляем последний элемент стека 

            //условие, которое определяет в какой стек (поезд) пойдёт наш вагон
            if (wagon == Wood) {
                woodTrain.push(wagon); //добавляем вагон типа "Wood" в поезд (стек) "woodTrain"
            }
            else {
                steelTrain.push(wagon); //добавляем вагон типа "Steel" в поезд (стек) "steelTrain"
            }
        }

        // Выводим результаты
        printTrain("Wood train", woodTrain);
        printTrain("Steel train", steelTrain);
    }

    //Функция (метод), которая выводит информация о составе поезда
    /*
    Параметры:
    title - название состава
    train - стек вагонов для печати
    */
    //const в параметрах и в конце обозначает, что мы не меняем сам поезд, только выводим его
    void printTrain(const string& title, const TrainStack<WagonType>& train) const {
        cout << "\n" << title << " (" << train.size() << " wagons):"; //вывод заголовка (какой поезд мы выводим)

        //Для вывода в правильном порядке используем временный вектор
        /*
        Пояснение:
        Если мы просто начнём выводить наш поезд, то выводить он будет в обратном порядке
        Пример неправильного вывода: (Поезд - Wood, Steel, Steel.)
        Если мы начнём его выводить, то выведется "Steel, Steel, Wood", так как брать мы можем только последний вагон
        */
        vector<WagonType> temp; //вектор (не стек) для временного хранения вагонов
        TrainStack<WagonType> copy = train; //копия исходного стека

        //Цикл, который переносит вагоны из копии стека в вектор. Цикл выполняется, пока копия стека не станет пустой
        while (!copy.empty()) {
            temp.push_back(copy.top());  //Перемещаем последний вагон из копии стека во временный вектор
            copy.pop(); //Удаляем последний вагон в копии
        }
        //После выполнения цикла, наш временный вектор будет содержать вагоны в обратном порядке
        //Чтобы вывести их в правильном порядке используем цикл for с реверсивными итераторами, они позволяют перебирать вектор с конца
        /*
        temp.rbegin() - начало обратной последовательности, грубо говоря, указывает откуда начинать
        temp.rend() - конец обратной последовательности, указывает где закончить
        */
        for (auto i = temp.rbegin(); i != temp.rend(); ++i) {
            cout << " - " << (*i == Wood ? "Wood" : "Steel");
            //"*i" - это тернарный оператор, он преобразует enum в строку
            //Простое объяснение:
            //*i == Wood ? "Wood" : "Steel" -> Если вагон типа Wood содержится в enum, то выводи "Wood", в противном случае выводи "Steel" 
        }
        cout << endl;
    }

    //Функция (метод), которая вызывает другую функцию и печатает оригинальный (смешанный) поезд
    void printOriginalTrain() const {
        printTrain("Original train", wagons);
    }
};

int main() {
    Train train; //создаём объект train из класса Train (вызов такой же как для структур)
    int wagonNum; //количество вагонов, который будут в нашем поезде

    cout << "Enter the number of wagons: ";
    cin >> wagonNum;

    train.createTrain(wagonNum); //создаём поезд длиной 'wagonNum'
    train.printOriginalTrain(); //печатаем этот поезд
    train.sortTrains(); //сортируем и выводим отсортированные поезда

    return 0;
}
